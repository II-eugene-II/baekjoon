# [백준 02553번 (마지막 팩토리얼 수)](https://www.acmicpc.net/problem/02553) - Python

![image](https://user-images.githubusercontent.com/104616990/174469273-30a3848c-7f9d-403d-ad11-f1f33498c25f.png)

---

0이 아닌 첫 자리를 편의상 **일의 자리** 라고 해봅니다.

12 X 16 = 192 이고, 2 X 6 = 12 에서 (N X M)의 **일의 자리**와 (N의 **일의 자리** X M의 **일의 자리**)가 동일하다고 생각해볼 수 있습니다.

따라서 다음과 같은 코드를 씁니다.

```
def New1(N):
    while(N % 10 ==0):
        N = N // 10
    return N%10

def fac1(N):
    if N == 1:
        return 1
    return New1(fac1(N-1)) * New1(N)

N = input()
N = int(N)

print(New1(fac1(N)))
```
New1은 **일의 자리**를 만드는 함수, fac1은 그를 이용하여 팩토리얼의 **일의 자리**를 만드는 함수입니다.

---

![image](https://user-images.githubusercontent.com/104616990/174469396-d29f8ee1-5f43-4895-9a7c-371989a98d1d.png)

처음 보는 오류가 뜹니다.

---

파이썬에서의 최대 재귀 횟수는 1천번 이라고 합니다. 따라서 1만 팩토리얼 같은걸 출력하려 하면 문제가 생깁니다.

따라서 첫 부분에 다음과 같은 코드를 추가해줍니다.

```
import sys
sys.setrecursionlimit(100000)
```

이래도 틀렸다고 나와서 질문칸을 보니, 15!에서 문제가 생깁니다.





...와 같이 해도 틀렸다고 나오니, 보아하니 5의 배수를 따로 처리하는 과정에서 문제가 생깁니다.

14!의 **일의 자리**는 2이고, 15를 곱하면 30이 나오므로 15!의 **일의 자리**는 3이라는 결론이 나옵니다.

---

하지만 14!의 **일의 자리와 십의 자리**는 12이므로, 15를 곱하면 180이 나오므로 15!의 **일의 자리**는 8이라는 결론이 나옵니다.

일의 자리만 남기면 문제가 생기는 셈입니다.

---

다른 방법을 고안해서, **일의 자리** 가 같은 숫자들끼리 묶으면 어떨까? 라는 결론이 나옵니다.

N = 12345 라는 숫자가 주어진다고 치면,

xxxx1 유형의 숫자는 xxxx에 0~1233까지 올 수 있고, 12341도 N보다 작으므로 총 1234+1개가 있습니다.
xxxx2 유형의 숫자는 xxxx에 0~1233까지 올 수 있고, 12342도 N보다 작으므로 총 1234+1개가 있습니다.
...
xxxx6 유형의 숫자는 xxxx에 0~1233까지 올 수 있고, 12346이 N보다 크므로 총 1234개가 있습니다.
...

xxx10 유형의 숫자는 xxx에 0~122까지 올 수 있고, 12310이 N보다 작으므로 총 123+1개가 있습니다.

이렇게 하면 M 이하의 **일의 자리**가 n인 함수를 다음과 같이 만들 수 있습니다.

```
def newFun(M, k, n):
    if (M % (10**(k+1)) // (10**k) >= n):
        return M // (10**(k+1)) +1
    else:
        return M // (10**(k+1))

n_List = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

for i in range(1, 10):
    for j in range(0, 7):
        n_List[i] += newFun(N, j, i)
```

이렇게 하고 나면 n_List[n]에는 n이 **일의 자리**인 숫자의 갯수가 나오고,

M = 123의 경우, n_list = [0, 16, 15, 14, 13, 13, 13, 13, 13, 13]이 나옵니다.

1이 **일의 자리**인 숫자들은 16개 있지만, 1은 곱해봐야 소용 없으므로 무시합니다.

6이 **일의 자리**인 숫자들이 13개 있지만, 2 * 6 = 12, 4 * 6 = 24, 6 * 6 = 36, 8 * 6 = 48에서 6은 의미 없는 수임을 알 수 있습니다, (n이 **일의 자리**인 수에 6을 곱해도 **일의 자리**는 n)

2가 **일의 자리**인 숫자들은 15개이고, 4가 **일의 자리**인 숫자들은 13개이고, 8이 **일의 자리**인 숫자들은 13개이고, 이를 퉁쳐서 한번에 하려면,

2가 **일의 자리**인 숫자들은 15 + 2 * 13 + 3 * 13 ( = 80)개 있다고 할 수 있습니다. (4는 2의 2제곱, 8은 2의 3제곱)

비슷한 예로, **일의 자리**가 3인 숫자들은 14개, 9인 숫자들은 13개 이므로 3이 **일의 자리**인 숫자들은 14 + 2 * 13 개 입니다.

5가 **일의 자리**인 숫자들은 13개이고, 5는 언제나 문제가 있으므로 2랑 합쳐서 10을 만들고 제거해줍니다.

따라서 2가 **일의 자리**인 숫자들은 67개 있다고 치고, 5가 **일의 자리**인 숫자들은 0개라고 생각해줍니다.

이떄, 2의 제곱꼴은 2, 4, 8, 16, 32, 64, 128...에서 **일의 자리**의 패턴이 2, 4, 8, 6 임을 알 수 있습니다.

비슷한 예로 3의 제곱꼴의 **일의 자리**의 패턴은 3, 9, 7, 1이고,

7의 제곱꼴의 **일의 자리**의 패턴은 7, 9, 3, 1임을 알 수 있습니다.

이를 이용하여 다음과 같은 코드를 씁니다.

```
def newFun(M, k, n):
    if (M % (10**(k+1)) // (10**k) >= n):
        return M // (10**(k+1)) +1
    else:
        return M // (10**(k+1))

N = input()
N = int(N)

if(N==1):
    print(1)
    exit()
elif(N==2):
    print(2)
    exit()
elif(N==3):
    print(6)
    exit()
elif(N==4):
    print(4)
    exit()
elif(N==5):
    print(2)
    exit()
elif(N==6):
    print(2)
    exit()
elif(N==7):
    print(4)
    exit()

n_List = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

for i in range(1, 10):
    for j in range(0, 7):
        n_List[i] += newFun(N, j, i)

n_List[2] -= n_List[5]

n_List[2] += 2 * n_List[4]
n_List[2] += 3 * n_List[8]

n_List[3] += 2 * n_List[9]

Ans = 1

if(n_List[2] %4 == 1):
    Ans *= 2
elif(n_List[2] %4 == 2):
    Ans *= 4
elif(n_List[2] %4 == 3):
    Ans *= 8
else:
    Ans *= 6

if(n_List[3] %4 == 1):
    Ans *= 3
elif(n_List[3] %4 == 2):
    Ans *= 9
elif(n_List[3] %4 == 3):
    Ans *= 7
else:
    Ans *= 1

if(n_List[7] %4 == 1):
    Ans *= 7
elif(n_List[7] %4 == 2):
    Ans *= 9
elif(n_List[7] %4 == 3):
    Ans *= 3
else:
    Ans *= 1

print(Ans%10)
```

초반부의 예외사항까지 뒀지만, 또 틀렸다고 뜹니다.

잘 생각해보니, 문제는 또 5의 배수에서 나옵니다.

예를 들어 2와 15를 곱하는 과정이라 하면, 위 알고리즘에선 15가 3 x 5 임을 간과하고 2와 5의 만남으로 그냥 없어졌다고 퉁치는 셈입니다.

---

어쩔 수 없이 검색을 해보던 중, [설명이 꽤 괜찮게 된 블로그](https://steady-coding.tistory.com/322)를 찾게 됩니다.

**일의 자리** (Unit Digit) 의 곱 계산은 오롯이 5의 배수만 아니라면 모두 통하는 방법입니다.

따라서 15!을 5의 배수는 따로 곱해준다면

$$ 5 \times 10 \times 15 \times 1 \times 2 \times 3 \times 4 \times 6 \times 7 \times 8 \times 9 \times 11 \times 12 \times 13 \times 14 $$

입니다.

5의 배수만 아니면 다 통하는 방법이므로, $$ 1 \times 2 \times 3 \times 4 $$ 의 **일의 자리**와
$$ 11 \times 12 \times 13 \times 14 $$ 의 일의 자리는 동일합니다.

$$ 1 \times 2 \times 3 \times 4 $ 의 **일의 자리**는 4, $ 6 \times 7 \times 8 \times 9 $$ 의 **일의 자리**는 4 (302"4") 입니다.

따라서 위 식의 **일의 자리**는 $$ 5 \times 10 \times 15 \times (4) \times (4) \times (4) \times $$ 와 동치입니다.

$$ 5 \times 10 \times 15 \times $$ 는 5로 공통적으로 묶어주면 $$ 5^3 \times 3! $$ 이고,

따라서 $$ 5 \times 10 \times 15 \times 1 \times 2 \times 3 \times 4 \times 6 \times 7 \times 8 \times 9 \times 11 \times 12 \times 13 \times 14 \times $$ 의 **일의 자리**는 $$ 5^3 \times 3! \times 4^3 $$ 의 **일의 자리**와 동일합니다.

$$ 5^3 \times 3! \times 4^3 = 5^3 \times 3! \times 2^3 \times 2^3 $$ 이고, $$ 5^3 \times 2^3 = 10^3 $$ 에서 제거해줘도 좋음을 알 수 있습니다.

---

이의 일반화된 식으로, $$(5M)!$$ 의 **일의 자리**는 $$ 2^M \times M! $$ 라는데에 있습니다.

또 중요한 것은, 2의 거듭제곱은 4개의 주기를 가지므로,  2^(M%4) * M! 로 계산을 더 단축 시킬 수 있습니다.

5M 꼴이 아니라면, 계속 하나씩 줄여가면서 곱해주면 됩니다.

---

해당 함수를 재귀함수 꼴로 만들어봅시다.

N이라는 숫자를 입력으로 받고,

N이 1이면 1, 2이면 2, 3이면 6, 4이면 2를 return 합니다.

N이 5로 나누어떨어지지 않으면, N * fac1(N-1) 을 return 합니다.

-> N이 5의 배수가 아니므로 N의 **일의 자리**를 곱해줘도 좋습니다.

N이 5로 나누어 떨어지면, 2^((N//5)%4) * fac1(N//5) 를 return 합니다.

```
def fac1(N):
    if(N == 1):
        return 1
    elif(N == 2):
        return 2
    elif(N == 3):
        return 6
    elif(N== 4):
        return 4

    if(N % 5 != 0):
        return (N%10) * fac1(N-1)
    else:
        return 2^((N//5)%4) * fac1(N//5)

N = input()
N = int(N)

print(fac1(N)%10)
```

그러나 이렇게 쓰면 5일때 오답으로 3을 출력합니다.

---

```
def fac1(N):
    if(N == 1):
        return 1
    elif(N == 2):
        return 2
    elif(N == 3):
        return 6
    elif(N== 4):
        return 4

    if(N % 5 != 0):
        return (N%10) * fac1(N-1)
    else:
        return (2 ** ((N//5)%4)) * fac1(N//5)

N = input()
N = int(N)

print(fac1(N)%10)
```

잘 생각해보니 거듭제곱은 ^가 아닌 ** 입니다. ^는 XOR 연산자 입니다.

### *백준에서 푼 42번째 문제*

---

백준 2553번의 자매 문제격으로 백준 2554번이 있습니다.

# [백준 02554번 (마지막 팩토리얼 수2)](https://www.acmicpc.net/problem/02554) - Python

![image](https://user-images.githubusercontent.com/104616990/174470134-1921d91f-326b-48a0-a992-c75a38863005.png)

다른 모든 사항이 같지만, 무려 100자리의 숫자를 커버해야한다는 조건 사항이 있습니다. 일반적으로는 풀 수 없어보이지만, 우선 기존의 코드가 가능한지를 시험해봅니다.

위 코드에서 49라는 숫자가 입력된다면 어떨까요?

fac(49) -> 49 * fac(48)

fac(48) -> 48 * fac(47)

fac(47) -> 47 * fac(46)

fac(46) -> 46 * fac(45)

fac(45) -> 2^(9%4) * fac(9)

fac(9) -> 9 * fac(8)

fac(8) -> 8 * fac(7)

fac(7) -> 7 * fac(6)

fac(6) -> 6 * fac(5)

fac(5) -> 2^1 * fac(1)

fac(1) = 1

또, 249라는 숫자가 입력된다면

249 -> 248 -> 247 -> 246 -> 245 -> 49 -> 48...으로 입력되고,

가장 길게 재귀반복 되려면 2 * (5 ^ K) - 1 꼴이 대략 5K번 재귀 반복된다는 걸 알 수 있고 (= O(logN)), 100자리를 넘는 가장 작은 이런 꼴의 숫자는

```
17936620343357658507823738666110926480387352856019401878490474033789325858379015699028968811035156245
```

라는 숫자입니다.

![image](https://user-images.githubusercontent.com/104616990/174470367-f60ccd6c-b92f-4806-8a05-eec82ce3349e.png)

1초는 커녕 0.001초도 간당간당하게 넘은 모습입니다. int형 변환에 꽤 오랜 시간이 걸릴거라 생각했는데 그렇지도 않은 모습입니다.

심지어 200자리의 숫자를 넣었는데도 0.003초가 되었습니다. 처음에는 문자열 가지고 큰 수의 연산이라도 해서 시간을 줄여야했나 싶었지만, 역시 파이썬이 큰 수 다루는데에는 편안합니다.

---

2553번이 난이도 실버급 문제임은 알고 있었으나, 2554는 제출 후에야 등급을 확인했는데

![image](https://user-images.githubusercontent.com/104616990/174470571-84a06704-b55e-47ba-be19-5e94b8dccf61.png)

![image](https://user-images.githubusercontent.com/104616990/174470585-ec87c937-8a06-4a4c-80ec-d04738bc1879.png)


무려 플래티넘II급이어서 경험치랑 등급이 심각하게 뻥튀기 되어버린 모습입니다(...)

---

굉장히 복잡한 문제이고, 플래티넘급 되니 슬슬 배울게 굉장히 많은 모습입니다.

```
import sys
sys.setrecursionlimit(100000)
```

파이썬은 그냥 뭐든 될 거라고 생각했는데 의외로 재귀가 1천번밖에 되지 않는 약한 모습도 보여주었습니다.

또한, N! 자체를 구하는데에는 O(n) 정도의 시간이 소요되지만, N! 의 **일의 자리** 를 구하는데에는 logn 정도의 시간으로 가능함을 알 수 있었습니다.

---

![image](https://user-images.githubusercontent.com/104616990/174470918-a42130d5-f738-44e3-932d-2a2f7ab79ede.png)

같은 플래티넘II급 문제들은 둘러보면 아직 배워보지도/건드려보지도 않은 알고리즘이 많이 나오고, 어떻게 풀어야 할 지도 모르겠고,

이렇게 쉬워보이는듯 하면서도 범위가 너무 넓어서 할 방법이 안보이고, 검색해도 안나오는(2945번은 검색해도 풀이나 힌트 그 어떤 글도 없음) 그러한 문제들이 굉장히 많습니다.

다음 플레티넘 문제를 푸는 일은 조금 기본기를 다듬고 해도 늦지 않을 듯 합니다. 

---

### *백준에서 푼 43번째 문제*
